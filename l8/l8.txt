I implemented LICM in Bril. I modified the `df.py` to add reaching analysis, and added `licm.py` which finds the backedges and natural loops, and execute loop invariant code motion by following rules listed on the lesson note. Based on the example code for cfg, dominators, and dataflow analysis, the process went pretty smooth without much debugging. For testing I used Bril benchmarks, all results came out correct and only a small subset of benchmarks shows a decrease in total_dyn_inst. I'm not sure what's the reason: maybe I restricted too much on what I deem to be safe instructions with no side effects? The one that decreases most(88%) is pythagorean_triple, it goes down from 61647 to 52468.  